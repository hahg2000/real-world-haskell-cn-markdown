# real-world-haskell-cn-markdown

## 简介

real-world-haskell-cn章节文本的markdown格式，部分章节 [在线预览](https://hahg2000.github.io/%E5%AD%A6%E4%B9%A0/Haskell%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/1.html) 

## 工具

+ [pandoc](https://github.com/jgm/pandoc/releases)
+ [批量转换代码](https://gist.github.com/zaiste/77a946bbba73f5c4d33f3106a494e6cd)
+ 操作步骤：
  + 下载 pandoc 并将 pandoc 所在目录配置成环境变量
  + 然后在 rst 文件所在目录运行 批量转换代码

## 版权

本文档和中文翻译、原书一样， 通过 CC 协议进行[署名-非商业性使用](http://creativecommons.org/licenses/by-nc/3.0/deed.zh)授权

+ 原书地址：https://book.realworldhaskell.org/
+ 中文翻译：https://github.com/huangz1990/real-world-haskell-cn

## 计划/TODO

+ [ ] 将错误的翻译改正
  + [x] 第一章：fixity 的翻译增加注解

+ [ ] 将转换格式不正确的改正
  + [x] 第一章
  + [x] 第二章
  + [x] 第三章
  + [x] 第四章
  + [x] 第五章
  + [x] 第六章
  + [x] 第七章
  + [x] 第八章
  + [x] 第九章
  + [x] 第十章
  + [x] 第十一章
  + [ ] 第十二章

## 翻译修改

1. 第三章的 4.6 模式匹配

> 原翻译：前面的章节介绍了代数数据类型的定义方法，本节将说明怎样去处理这些类型的值。
>
> 对于某个类型的值来说，应该可以做到以下两点：
>
> * 如果这个类型有一个以上的值构造器，那么应该可以知道，这个值是由哪个构造器创建的。
>
> * 如果一个值构造器包含不同的成分，那么应该有办法提取这些成分。
>
> 对于以上两个问题， Haskell 有一个简单且有效的解决方式，那就是类型匹配。
>
> 模式匹配允许我们查看值的内部，并将值所包含的数据绑定到变量上。以下是一个对 `Bool` 类型值进行模式匹配的例子，它的作用和 `not` 函数一样：

前面的章节介绍了如何定义代数数据类型，本节将说明怎样去使用这些类型的值。

我们如果有了这些代数数据类型，我们可以使用这些代数数据类型做下面的这两件事：

-   如果这个类型有一个以上的值构造器，我们可以知道这个值是由哪个构造器创建的。
-   如果一个值构造器包含不同的数据成分，那么可以获取到这些成分。

对于以上两个问题， Haskell 有一个简单且有效的解决方式，那就是 *模式匹配*。

模式匹配允许我们查看值的内部，并将值（所包含的数据）绑定到变量上。以下是一个对 `Bool` 类型值进行模式匹配的例子，它的作用和 `not` 函数一样：
