1. 第三章的 4.5 模式匹配

> 原翻译：前面的章节介绍了代数数据类型的定义方法，本节将说明怎样去处理这些类型的值。
>
> 对于某个类型的值来说，应该可以做到以下两点：
>
> * 如果这个类型有一个以上的值构造器，那么应该可以知道，这个值是由哪个构造器创建的。
>
> * 如果一个值构造器包含不同的成分，那么应该有办法提取这些成分。
>
> 对于以上两个问题， Haskell 有一个简单且有效的解决方式，那就是类型匹配。
>
> 模式匹配允许我们查看值的内部，并将值所包含的数据绑定到变量上。以下是一个对 `Bool` 类型值进行模式匹配的例子，它的作用和 `not` 函数一样：

前面的章节介绍了如何定义代数数据类型，本节将说明怎样去使用这些类型的值。

我们如果有了这些代数数据类型，我们可以使用这些代数数据类型做下面的这两件事：

-   如果这个类型有一个以上的值构造器，我们可以知道这个值是由哪个构造器创建的。
-   如果一个值构造器包含不同的数据成分，那么可以获取到这些成分。

对于以上两个问题， Haskell 有一个简单且有效的解决方式，那就是 *模式匹配*。

模式匹配允许我们查看值的内部，并将值（所包含的数据）绑定到变量上。以下是一个对 `Bool` 类型值进行模式匹配的例子，它的作用和 `not` 函数一样：

2. 第三章的第 6 小节 参数化类型

> 原翻译：我们向 `Maybe` 的类型构造器传入某种类型作为参数，例如`Maybe Int` 或 `Maybe [Bool]`。如我们所希望的那样，这些都是不同的类型（译注：可能省略了"但是都可以成功传入作为参数"）

我们向 `Maybe` 这个类型构造器传入个参数来新建个特定的类型，例如 `Meybe Int` 或 `Maybe [Bool]` 。如我们所期望的那样，这些都是不同的类型。